// 大文件排序
package main

import (
	"fmt"
	"hash/crc32"
	"os"
	"time"
)

const (
	PartitionSize = 128 * 1024 * 1024 // 128MB
)

func BigDataSort(file string) error {
	f, err := os.Open(file)
	if err != nil {
		return err
	}
	defer f.Close()
	// 读取文件大小，做切割处理
	stat, err := f.Stat()
	if err != nil {
		return err
	}
	// 每个分区按照128M处理，最后一个分区，若大于128M / 2 = 64MB，则合并至一个分区，否则拆分为多个文件
	partitionCount := stat.Size() / PartitionSize
	tailSize := stat.Size() % PartitionSize
	if tailSize > PartitionSize/2 {
		partitionCount++
	}

	// 清理所有临时文件
	defer func() {
		for i := 0; i < partitionCount; i++ {
			file := fmt.Sprintf("partition_%d.dat", i)
			os.Remove(file)
		}
	}()

	// 按照分区数，切割文件
	for i := 0; i < partitionCount; i++ {
		outputFile = fmt.Sprintf("partition_%d.dat", i)
		o, err := os.Create(outputFile)
		if err != nil {
			return err
		}
		// 将文件内容读入内存
		o.Close()
	}
	return nil
}

func MergeSort(files []string, output string) {
}

func main() {
}
